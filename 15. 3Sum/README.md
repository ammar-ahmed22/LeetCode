<!-- 
  AUTOGENERATED: DO NOT EDIT
  name: 15. 3Sum
  difficulty: Medium
  languages: Python
  url: https://leetcode.com/problems/3sum/
 -->
## Question
Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

## Solution
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        nums.sort()
        
        result = set()
        
        for i in range(len(nums)):
            
            target = -nums[i]
            
            start, end = i + 1, len(nums) - 1
            
            while start < end:
                
                twoSum = nums[start] + nums[end]
                
                if twoSum == target:
                    result.add((nums[i], nums[start], nums[end]))
                    start += 1
                    end -= 1
                elif twoSum < target:
                    start += 1
                else:
                    end -= 1
        
        return result
        
```

## Explanation
- Sort the array to start so we can implement a two-pointer approach
- Create a set for the result so that we don't have any duplicates
- Iterate over all numbers
  * As we are looking for a sum of 0, we can negate the number at index `i` and look for two other numbers which add up to that value.
    + e.g. if `nums[i] = 3`, we are looking for two other numbers that add up to `-3`.
  * Initialize a left and right pointer starting at `i + 1` and the end of the array
    + Iterate looking for the two values that add up to the negated value
    + If the "two sum" is less than the negated value, moved the left pointer up
      * As we are looking for a larger sum
    + Otherwise, move right pointer down
    + When target is found add values to the set

## Complexity
**Runtime**: O(n^2logn)<br/>
> Sorting is O(nlogn), algorithm is O(n)
**Space**: O(n)